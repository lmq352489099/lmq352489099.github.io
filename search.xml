<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML语义化]]></title>
    <url>%2Fjs%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98.html</url>
    <content type="text"><![CDATA[堆栈内存的作用JS 中的内存堆内存和栈内存，所有堆栈内存的处理，浏览器会自行在内部执行 栈内存： 提供一个供 JS 代码自上而下执行的环境（作用域，代码都是在栈内存中执行的） 由于基本类型比较简单，它们都是直接在栈内存中开辟一个位置，直接把值存储进去的 堆内存：引用值对应的空间存储引用类型的（对象：键值对，函数：代码字符串） 堆内存的释放让所有引用堆内存空间地址的变量赋值为 null 即可，当堆内存没有被任何的变量或者其他东西引用时，就会在浏览器执行垃圾回收的时候，被销毁掉。 堆内存释放后，里面存储的值也就会被释放掉。 栈内存的释放全局作用域会在页面关闭或者刷新的时候释放。（栈内存释放后，存储在栈内存中的值也都会销毁。）私有作用域：一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉，但是也有特殊的情况。 函数执行完成，当前形成的栈内存中，某些内容被栈内存意外的变量一直占用，此时栈内存不能释放，栈内存中存储的基本值也不会被释放，一直保存下来。最典型的就是闭包。 123456789101112var i = 1;function fn(i) &#123; return function(n) &#123; console.log(n + (++i)); &#125;&#125;var f = fn(2); //=&gt; i = 2f() //=&gt; i = 3f(3); //=&gt;7, i = 3 n =3，执行 n + (++i) =&gt; 3 + 4 = 7fn(5)(6); //=&gt;12, i = 5 n = 6，执行 n + (++i) =&gt; 6 + 6 = 12fn(7)(8); //=&gt;16, i = 7 n = 8，执行 n + (++i) =&gt; 8 + 8 = 16f(4); //=&gt;8, i = 3 n = 4，执行 n + (++i) =&gt; 4 + 4 = 8]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调用摄像头]]></title>
    <url>%2Fshexiangtou.html</url>
    <content type="text"><![CDATA[前言 今天闲来无事，发现有这个调用摄像头的todo，网上查了一下，果然 js 有调用摄像头的 api，为此自己写一个 demo ，避免忘记。 正文 调用摄像头一共有两种实现方式，一种是使用navigator.getUserMedia（该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性），前面一种已经从 Web 标准中删除，仅为了向后兼容而存在，第二种是使用navigator.mediaDevices.getUserMedia(推荐使用),这两种方法 Safari 貌似都不支持。。。。 第二种navigator.mediaDevices.getUserMedia实现方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;拍照2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="take"&gt;拍照&lt;/button&gt; &lt;br /&gt; &lt;video id="v" style="width: 640px;height: 480px;"&gt;&lt;/video&gt; &lt;canvas id="canvas" style="display:none;"&gt;&lt;/canvas&gt; &lt;br /&gt; &lt;img src="http://placehold.it/640&amp;text=Your%20image%20here%20..." id="photo" alt="photo"&gt; &lt;script&gt; !(function () &#123; // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;; &#125; if (navigator.mediaDevices.getUserMedia === undefined) &#123; navigator.mediaDevices.getUserMedia = function (constraints) &#123; // 首先，如果有getUserMedia的话，就获得它 var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口 if (!getUserMedia) &#123; return Promise.reject(new Error('getUserMedia is not implemented in this browser')); &#125; // 否则，为老的navigator.getUserMedia方法包裹一个Promise return new Promise(function (resolve, reject) &#123; getUserMedia.call(navigator, constraints, resolve, reject); &#125;); &#125; &#125; const constraints = &#123; video: true, audio: false &#125;; let videoPlaying = false; let v = document.getElementById('v'); let promise = navigator.mediaDevices.getUserMedia(constraints); promise.then(stream =&gt; &#123; // 旧的浏览器可能没有srcObject if ("srcObject" in v) &#123; v.srcObject = stream; &#125; else &#123; // 防止再新的浏览器里使用它，应为它已经不再支持了 v.src = window.URL.createObjectURL(stream); &#125; v.onloadedmetadata = function (e) &#123; v.play(); videoPlaying = true; &#125;; &#125;).catch(err =&gt; &#123; console.error(err.name + ": " + err.message); &#125;) document.getElementById('take').addEventListener('click', function () &#123; if (videoPlaying) &#123; let canvas = document.getElementById('canvas'); canvas.width = v.videoWidth; canvas.height = v.videoHeight; canvas.getContext('2d').drawImage(v, 0, 0); let data = canvas.toDataURL('image/webp'); document.getElementById('photo').setAttribute('src', data); &#125; &#125;, false); &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM的映射机制]]></title>
    <url>%2FDOM.html</url>
    <content type="text"><![CDATA[前言这在我们平常操作 DOM 的时候司空见惯。就比如：我通过获取一个元素来改变其样式，自然而然的反映到 HTML 页面中。 但是，我们操作 JS 对象的时候，本质上操作的是 JS 堆内存，为什么会反映到页面中呢？就是因为浏览器存在这个 DOM 的映射机制。 1. 什么是 DOM 的映射机制？我们使用 JS 从页面获取到的元素对象，或者自己手动创建的已经插入页面的元素对象，与页面中的 HTML 元素是绑定在一起的。也就是说修改其中一个，另一个也会跟着自动修改。这就是 DOM 的映射机制。 2. 形成映射的几种情形改变元素对象的属性这是我们最常用到的一种情形。当我们需要为元素添加自定义属性、或者修改属性等，就可以从页面中获取到元素对象，然后对其进行修改，就能够自动反映到 HTML 页面元素上。 1234567//=&gt; 修改从页面中获取的元素样式Div.style.color = 'red';//=&gt; 修改已经插入页面的元素的属性var p = document.createElement('p');box.appendChild(p);p.dataset.index = 1; 这两种方式得到的元素对象，修改其属性，都能够直接反映到页面中，不需要再次插入页面中。 在元素内部继续添加元素12345678//=&gt; 在其内部插入标签或文本var list = Div.getElementsByTagName('li');console.log(list); // 空的元素集合Div.innerHTML('&lt;li&gt;&lt;/li&gt;');console.log(list); // 有一个元素集合//=&gt; 添加自己创建的元素对象，同样原理Div.appendChild(p); 在容器中的数据绑定前，我们获取容器中元素，得到一个空的元素集合，容器数据绑定后，我们不需要重新获取，DOM 的映射机制会帮我们把新增加的元素映射到之前获取的空集合中，让其变为有元素的集合。 在页面中追加已有元素12list = Div.getElementsByTagName('li')[0];Div.appendChild(list); appendChild 在追加元素对象的时候，如果这个元素在容器中已经存在，此时并不是克隆一份新的追加到末尾，而是把原有的元素移动到末尾。 其根本原因在于，同一个元素在页面中，只能够有一个位置。把 JS 元素对象插入页面中某个位置，实际上就是把其绑定的 HTML 元素移动到那个位置上。 这里的元素已经存在有两种情形： 元素是从页面中获取到的 创建的元素已经添加过一次，再次添加时因此，就无需手动移除原先的元素，再进行添加。直接插入即可。 3. 特殊情况querySelectAll 获取的集合是静态集合（staticNodeList），不存在上述所谓的映射机制，基于这个方法，数据绑定完成后需要重新获取一次才可以。1234var box = document.querySelectorAll('#box');var box1 = document.getElementById('box');console.log(box); //=&gt; 获取到的是 NodeList 对象console.dir(box1); //=&gt; 而这里获取到的是 HTMLElement 的实例 这个特殊的 NodeList 不存在与 HTML 页面元素的映射，而且没有很多 HTMLElement 实例才拥有的方法。因此，使用这个方法的时候每次操作时，都应该重新获取。 另外，jQuery 中获取的元素同样不存在这些映射，实现映射需要使用其内部的方法，而且要使用原生 HTMLElement 实例的方法，需要通过后面加 [0] 的方法转换为原生元素对象。 另外，由于存在这种映射机制，在使用循环 DOM 中，改变了 DOM 的顺序，那么循环原本的顺序也就改变了。1234[].forEach.call(children, (item)=&gt; &#123; parent.appendChild(item);&#125;);//=&gt; 这样做你会发现，循环完成后 children 改变了，不符合预期 因此，真实项目中，不应该过分依赖于 DOM 的映射机制。 生命的意义不仅是活着,而是我们给别人的生命带来了何种不同]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[林敏强]]></title>
    <url>%2Flmq.html</url>
    <content type="text"><![CDATA[21佳科技发啦啊了圣诞节啊离开多久啊来得及三来得及阿里]]></content>
      <categories>
        <category>123</category>
      </categories>
      <tags>
        <tag>123</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML语义化]]></title>
    <url>%2Fyuyihua.html</url>
    <content type="text"><![CDATA[前言HTML是超文本标记（Hyper Text Markup Language）的缩写，在网页设计中又把它称为网页的结构层。它的学习很简单，只要多利用业余时间去记忆、练习，一到两天时间就能掌握，并写出一个简单页面。 这里推荐一个快速入门的网址：http://www.w3school.com.cn/ 一、对于html的学习1. 首先是对html的整体结构的认识，即&lt;!DOCTYPE html&gt;的声明、html标签、head标签、body标签； 2. 其次是对head里面的标签的认识和使用，如meta、link、title、script、style等，在网页的优化上特别重要； 3. 最后是对body里面的标签的认识和使用，这也是网页上面呈现的内容，学html大部分时间都要花在这上面。要对常用标签的含义、用法、性质以及自带的属性都要熟练掌握，不常用标签能知道含义以及用法。 要掌握的精髓就在于在什么样的情况下运用哪个标签才能达到最好的效果。 二、标签语义化1. 其重要作用在于： 2. 网页结构合理 ； 3. 利于开发调试和后期维护（让自己和别人能够比较容易看懂代码）； 4.利于搜索引擎SEO优化。搜索引擎不能识别内容，只能识别标签语义从而知道这部分是什么内容（让搜索引擎能看懂）。有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取； 5.方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）。 但是，必须认识到，并不是说我们只能使用有语义的标签，而应当是在需要有语义，需要被SEO识别的情况下才必须使用有语义标签（如自己网页的主题以及重要内容等）。在不需要的情况下，也根据情况使用无语义标签。如div加CSS的页面布局、span添加一些只为实现效果的块或者描述，不需要有语义，不然也容易造成语义混乱。这是因为由标签传达的含义比浏览器显示文本的方式更为重要 文字1. 在有一段文字显示的情况下，必须使p标签来包含。里面可含有无语义标签div/span以及其他有语义的标签。 如：blockquote块引用，长引用（要添加cite属性引用地址）、q短的行内引用cite定义引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题著作的标题、address文档作者或拥有者的联系信息、code代码abbr缩写（要添加title标签说明原文）、time时间、mark标注、ruby注释、strong强调 （特别注意，这个标签权重很高，用于特别强调的文本。搜索引擎对其有很高的识别。）、details可展开样式（details里面使用添加标题，后面接展开内容)等等…… 2. 标题使用h1,h2,h3,h4标签,其中h5,h6权重太小一般不使用。其中的样式，即字体大小、颜色等都可以用CSS定义重新定义； 3. 标签中应该使用的是有含义的。基于内容的样式标签会告诉浏览器它所包含的文本具有特定的含义、上下文或者用法。是浏览器和搜索引擎所能识别的。不应该使用纯粹为了设定样式而存在的标签。设定样式应当由样式表（CSS）完成。 图片 如果图片作为HTML的一部分，需要被搜索引擎识别，则用img，不需要，则可以使用背景来显示图片； img标签中的alt和title属性。其中，alt属性用于图片描述，是给搜索引擎看的，图片无法显示时，显示alt中的文字。title属性也用于图片描述，是给用户看的，鼠标移动到图片时显示title中的文字。对于img标签，两个属性都尽量添加。（对于title值，在很多元素中都可以使用，比如在布局中无法完全显示的一条新闻或者消息等，在鼠标移动到上面时显示完全的内容是很好的一种用户体验）； figure元素和figcaption元素。figure元素用于包含图片和图注，figurecaption元素用于表示图注文字。在有图片和图注的情况下，使用这两个元素会使页面语义更好。 表格表格中有table、tr、td、th、caption、thead、tbody、tfoot。语义上，th为表头单元格，caption为表格标题，thead、tbody、tfoot把表格分为三部分。这三样在效果上并不需要用到，但在良好的语义上，尽量使用 表单1. lable绑定控件。lable使用于关联控件，解释控件的意义以及有一定点击效果； 2. placeholder占位符值和value值。表单中文本框的默认值，类似提示文本。在需要用户输入文字的控件中尽量使用； 3. fieldset表单控件分组。（只在有需要的时候使用，多数表单不分组），legend标签为 fieldset 元素定义标题。 新增标签在HTML5中添加了很多结构标签，增强了页面布局结构的语义，下面举例： 1. nav导航 2. section内容块区 3. article 文章 4. aside辅助信息 5. hgroup标题组合 6. footer页脚 7. header头部、标题 8. figure独立的流内容 优秀的人，不是不合群，而是他们合群的人里面没有你]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
